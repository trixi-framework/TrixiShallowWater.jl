<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Okushiri tsunami · TrixiShallowWater.jl</title><meta name="title" content="Okushiri tsunami · TrixiShallowWater.jl"/><meta property="og:title" content="Okushiri tsunami · TrixiShallowWater.jl"/><meta property="twitter:title" content="Okushiri tsunami · TrixiShallowWater.jl"/><meta name="description" content="Documentation for TrixiShallowWater.jl."/><meta property="og:description" content="Documentation for TrixiShallowWater.jl."/><meta property="twitter:description" content="Documentation for TrixiShallowWater.jl."/><meta property="og:url" content="https://trixi-framework.github.io/TrixiShallowWater.jl/tutorials/elixir_shallowwater_monai_tsunami/"/><meta property="twitter:url" content="https://trixi-framework.github.io/TrixiShallowWater.jl/tutorials/elixir_shallowwater_monai_tsunami/"/><link rel="canonical" href="https://trixi-framework.github.io/TrixiShallowWater.jl/tutorials/elixir_shallowwater_monai_tsunami/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TrixiShallowWater.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><a class="tocitem" href="../elixir_shallowwater_dam_break_triangular/">Dam break over triangular bottom topograhy</a></li><li class="is-active"><a class="tocitem" href>Okushiri tsunami</a><ul class="internal"><li><a class="tocitem" href="#Load-required-packages"><span>Load required packages</span></a></li><li><a class="tocitem" href="#Visualize-the-original-bathymetry"><span>Visualize the original bathymetry</span></a></li><li><a class="tocitem" href="#Create-an-unstructured-mesh"><span>Create an unstructured mesh</span></a></li><li><a class="tocitem" href="#Discretize-the-problem-setup"><span>Discretize the problem setup</span></a></li><li><a class="tocitem" href="#Run-the-simulation"><span>Run the simulation</span></a></li><li><a class="tocitem" href="#Postprocessing-the-solution-data"><span>Postprocessing the solution data</span></a></li><li><a class="tocitem" href="#Putting-it-all-together"><span>Putting it all together</span></a></li></ul></li></ul></li><li><span class="tocitem">Advanced topics &amp; developers</span><ul><li><a class="tocitem" href="../../development/">Development</a></li><li><a class="tocitem" href="../../testing/">Testing</a></li></ul></li><li><a class="tocitem" href="../../authors/">Authors</a></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li><li><a class="tocitem" href="../../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../../license/">License</a></li><li><a class="tocitem" href="../../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Okushiri tsunami</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Okushiri tsunami</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/trixi-framework/TrixiShallowWater.jl/blob/main/docs/src/tutorials/elixir_shallowwater_monai_tsunami.jl#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Okushiri-Tsunami"><a class="docs-heading-anchor" href="#Okushiri-Tsunami">Okushiri Tsunami</a><a id="Okushiri-Tsunami-1"></a><a class="docs-heading-anchor-permalink" href="#Okushiri-Tsunami" title="Permalink"></a></h1><p>In this tutorial, we will use the shallow water equations with wetting and drying on an unstructured quadrilateral mesh to numerically approximate the Okushiri tsunami experiment that models the wave runup near the village of Monai on Okushiri Island. This benchmark problem comes from a 1/400 scale laboratory experiment that used a wave tank at the Central Research Institute for Electric Power Industry (CRIEPI) in Abiko, Japan.</p><p>This is an application that exercises the ability of TrixiShallowWater.jl to model tsunami runup onto a complex three-dimensional coastline. The bathymetry data for this test case is approximated with bicubic splines. A thorough description of this problem setup and the original data files are available <a href="https://isec.nacse.org/workshop/2004_cornell/bmark2.html">here</a>. Additional information about this benchmark problem and comparison results can be found in the papers:</p><ul><li>J. Hou, Q. Liang, H. Zhang, and R. Hinkelmann (2015) An efficient unstructured MUSCL scheme for solving the 2D shallow water equations <a href="https://doi.org/10.1016/j.envsoft.2014.12.007">DOI: 10.1016/j.envsoft.2014.12.007</a></li><li>M. Ricchiuto (2015) An explicit residual based approach for shallow water flows <a href="https://doi.org/10.1016/j.jcp.2014.09.027">DOI: 10.1016/j.jcp.2014.09.027</a></li></ul><p>The tutorial will cover:</p><ul><li>Create an unstructured quadrilateral mesh with <a href="https://github.com/trixi-framework/HOHQMesh.jl">HOHQMesh.jl</a></li><li>Set up a SWE solver for wet/dry transitions</li><li>Approximate bathymetry data with <a href="https://github.com/trixi-framework/TrixiBottomTopography.jl">TrixiBottomTopography.jl</a></li><li>Create custom initial conditions, boundary conditions, and source terms</li><li>Postprocess solution data with <a href="https://github.com/trixi-framework/Trixi2Vtk.jl">Trixi2Vtk.jl</a></li><li>Visualization with <a href="https://www.paraview.org/download/">ParaView</a></li></ul><h2 id="Load-required-packages"><a class="docs-heading-anchor" href="#Load-required-packages">Load required packages</a><a id="Load-required-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Load-required-packages" title="Permalink"></a></h2><p>The core solver component is TrixiShallowWater.jl, which requires <a href="https://trixi-framework.github.io/Trixi.jl/stable/#Trixi.jl"><code>Trixi.jl</code></a> for the underlying spatial discretization and <code>OrdinaryDiffEqSSPRK.jl</code> for time integration. <code>HOHQMesh.jl</code> is needed to generate an unstructured mesh for this problem. <code>TrixiBottomTopography.jl</code> is needed to create a bathymetry approximation that is directly usable by Trixi.jl. Finally, we include <a href="https://docs.makie.org/stable/"><code>CairoMakie.jl</code></a> for insitu visualization and <code>Trixi2Vtk.jl</code> for postprocessing.</p><pre><code class="language-julia hljs">using HOHQMesh
using OrdinaryDiffEqSSPRK
using Trixi
using TrixiShallowWater
using TrixiBottomTopography
using CairoMakie
using Trixi2Vtk</code></pre><h2 id="Visualize-the-original-bathymetry"><a class="docs-heading-anchor" href="#Visualize-the-original-bathymetry">Visualize the original bathymetry</a><a id="Visualize-the-original-bathymetry-1"></a><a class="docs-heading-anchor-permalink" href="#Visualize-the-original-bathymetry" title="Permalink"></a></h2><p>First, we obtain and plot the raw bathymetry data. An examination of the bathymetry and its features will aid in designing an appropriate mesh for the discretization. We download the raw bathymetry data to make it available locally</p><pre><code class="language-julia hljs">raw_bathymetry_file = Trixi.download(&quot;https://gist.githubusercontent.com/andrewwinters5000/305d203c0409d26075aa2993ff367637/raw/df480a6ff63da1916a19820b060abfea83d40dbf/raw_monai_bathymetry.txt&quot;,
                                     joinpath(@__DIR__, &quot;raw_monai_bathymetry.txt&quot;));</code></pre><p>Next, we open and parse the bathymetry data to visualize it</p><pre><code class="language-julia hljs">file = open(raw_bathymetry_file)
lines = readlines(file)
close(file)

x = zeros(Float64, length(lines) - 1)
y = zeros(Float64, length(lines) - 1)
z = zeros(Float64, length(lines) - 1)

# Skip the header of the file
for j in 2:length(lines)
    current_line = split(lines[j])
    x[j - 1] = parse(Float64, current_line[1])
    y[j - 1] = parse(Float64, current_line[2])
    z[j - 1] = -parse(Float64, current_line[3])
end

surface(x, y, z,
        axis = (type = Axis3, xlabel = &quot;x [m]&quot;, ylabel = &quot;y [m]&quot;, zlabel = &quot;z [m]&quot;),
        colormap = :greenbrownterrain)</code></pre><img src="2584cfc2.png" alt="Example block output"/><p>From the bathymetry visualization we can identify that there are several regions of interest that require higher resolution to create an accurate approximation. In particular, there is a island located near the center of the domain and a cliff side that dominates the right portion of the domain.</p><p>This information is useful to guide the creation of an unstructured quadrilateral mesh. In HOHQMesh, we set a background grid and then specify targeted refinement regions to add more elements where more resolution is required to resolve the bathymetry.</p><h2 id="Create-an-unstructured-mesh"><a class="docs-heading-anchor" href="#Create-an-unstructured-mesh">Create an unstructured mesh</a><a id="Create-an-unstructured-mesh-1"></a><a class="docs-heading-anchor-permalink" href="#Create-an-unstructured-mesh" title="Permalink"></a></h2><p>To begin, we create a new mesh project. The output files created by HOHQMesh will be saved into the &quot;out&quot; folder and carry the same name as the project, in this case &quot;monai_shore&quot;.</p><pre><code class="language-julia hljs">monai = newProject(&quot;monai_shore&quot;, &quot;out&quot;);</code></pre><p>Next, we set the polynomial order for the boundaries to be linear, i.e., polynomials of degree one. The file format is set to <a href="https://trixi-framework.github.io/HOHQMesh/TheISMMeshFileFormats/#ism">&quot;ISM-V2&quot;</a> as it is compatible with <code>UnstructuredMesh2D</code> mesh type that will be used later in the solver.</p><pre><code class="language-julia hljs">setPolynomialOrder!(monai, 1)
setMeshFileFormat!(monai, &quot;ISM-V2&quot;);</code></pre><p>The rectangular domain for this problem has no interior or exterior boundary curves. To suppress extraneous output from HOHQMesh during the mesh generation process we create an empty MODEL dictionary.</p><pre><code class="language-julia hljs">HOHQMesh.getModelDict(monai);</code></pre><p>Now we can set a background Cartesian box mesh required to define the length scales in the mesh generation process. The domain for this problem setup is <span>$[0.0, 5.488] \times [0.0, 3.402]$</span>. To initialize the mesh, the domain boundary edges are provided in <code>bounds</code> with order <code>[top, left, bottom, right]</code>. The background grid is coarse with eight elements in the <span>$x$</span>-direction and four elements in the <span>$y$</span>-direction.</p><pre><code class="language-julia hljs">bounds = [3.402, 0.0, 0.0, 5.488]
N = [8, 4, 0]
addBackgroundGrid!(monai, bounds, N)</code></pre><p>From the inspection of the bathymetry visualization above we indicate regions in the domain to target additional refinement during mesh generation. One <a href="https://trixi-framework.github.io/HOHQMesh.jl/stable/reference/#HOHQMesh.newRefinementCenter-Tuple{String,%20String,%20Array{Float64},%20Float64,%20Float64}"><code>RefinementCenter</code></a> is placed around the island near the center of the domain. Three <a href="https://trixi-framework.github.io/HOHQMesh.jl/stable/reference/#HOHQMesh.newRefinementLine-Tuple{String,%20String,%20Array{Float64},%20Array{Float64},%20Float64,%20Float64}"><code>RefinementLine</code></a> areas are placed in the wake region of said island and the coastline.</p><pre><code class="language-julia hljs">island = newRefinementCenter(&quot;island&quot;, &quot;smooth&quot;, [3.36, 1.68, 0.0], 0.1, 0.15)
wake = newRefinementLine(&quot;wake&quot;, &quot;smooth&quot;, [3.75, 1.7, 0.0],
                         [4.75, 1.7, 0.0], 0.15, 0.2)
shoreline_top = newRefinementLine(&quot;shoreline&quot;, &quot;smooth&quot;, [4.816, 3.374, 0.0],
                                  [4.83, 2.366, 0.0], 0.15, 0.168)
shoreline_bottom = newRefinementLine(&quot;shoreline&quot;, &quot;smooth&quot;, [4.97, 2.3, 0.0],
                                     [5.32, 1.4, 0.0], 0.075, 0.22);</code></pre><p>These four refinement regions are then added into the <code>monai</code> mesh project.</p><pre><code class="language-julia hljs">add!(monai, island)
add!(monai, wake)
add!(monai, shoreline_top)
add!(monai, shoreline_bottom)</code></pre><p>One can plot the current project to inspect the background grid and refinement region locations using the command</p><pre><code class="language-julia hljs">plotProject!(monai, GRID + REFINEMENTS);</code></pre><p><img src="https://github.com/user-attachments/assets/9666e5da-c8d6-42e5-be38-0c54f3e15d6c" alt="mesh_before"/></p><p>The locations of the refinement regions look good so that we can generate the mesh. The call to <code>generate_mesh</code> prints mesh also prints quality statistics and updates the visualization.</p><pre><code class="language-julia hljs">generate_mesh(monai);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
 *******************
 2D Mesh Statistics:
 *******************
    Total time             =    1.4868999999999997E-002
    Number of nodes        =          600
    Number of Edges        =         1173
    Number of Elements     =          574
    Number of Subdivisions =            4

 Mesh Quality:
         Measure         Minimum         Maximum         Average  Acceptable Low Acceptable High       Reference
     Signed Area      0.00185871      0.64053016      0.03252644      0.00000000    999.99900000      1.00000000
    Aspect Ratio      1.06385060      2.13278937      1.29691264      1.00000000    999.99900000      1.00000000
       Condition      1.00925079      1.89817525      1.17459498      1.00000000      4.00000000      1.00000000
      Edge Ratio      1.14552059      2.78677506      1.57612085      1.00000000      4.00000000      1.00000000
        Jacobian      0.00149698      0.59304675      0.02682698      0.00000000    999.99900000      1.00000000
   Minimum Angle     37.88262803     89.90492266     75.82673070     40.00000000     90.00000000     90.00000000
   Maximum Angle     90.06447142    143.84504916    105.60605711     90.00000000    135.00000000     90.00000000
       Area Sign      1.00000000      1.00000000      1.00000000      1.00000000      1.00000000      1.00000000</code></pre><p><img src="https://github.com/user-attachments/assets/6157a39c-e8ff-443a-b4d3-e0061188bea6" alt="mesh_after"/></p><p>Additionally, this will output the following files to the <code>out</code> folder:</p><ul><li><code>monai_shore.control</code>: A HOHQMesh control file for the current project.</li><li><code>monai_shore.tec</code>: A TecPlot formatted file to visualize the mesh with other software, e.g., ParaView.</li><li><code>monai_shore.mesh</code>: A mesh file with format &quot;ISM-V2&quot;.</li></ul><h2 id="Discretize-the-problem-setup"><a class="docs-heading-anchor" href="#Discretize-the-problem-setup">Discretize the problem setup</a><a id="Discretize-the-problem-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Discretize-the-problem-setup" title="Permalink"></a></h2><p>With the mesh in hand we can proceed to construct the solver components and callbacks for the tsunami runup problem.</p><p>For this example we solve the two-dimensional shallow water equations, so we use the <a href="../../reference/#TrixiShallowWater.ShallowWaterEquationsWetDry2D"><code>ShallowWaterEquationsWetDry2D</code></a> and specify the gravitational acceleration to <code>gravity = 9.812</code> as well as a background water height <code>H0 = 0.0</code>. In contrast to the <a href="https://trixi-framework.github.io/Trixi.jl/stable/reference-trixi/#Trixi.ShallowWaterEquations2D"><code>Trixi.ShallowWaterEquations2D</code></a> type, this equation type allows contains additional parameters and methods needed to handle wetting and drying.</p><pre><code class="language-julia hljs">equations = ShallowWaterEquationsWetDry2D(gravity = 9.81, H0 = 0.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ ShallowWaterEquationsWetDry2D                                                                    │
│ ═════════════════════════════                                                                    │
│ #variables: ………………………………………………… 4                                                                │
│ │ variable 1: …………………………………………… h                                                                │
│ │ variable 2: …………………………………………… h_v1                                                             │
│ │ variable 3: …………………………………………… h_v2                                                             │
│ │ variable 4: …………………………………………… b                                                                │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>Next, we construct an approximation to the bathymetry with TrixiBottomTopography.jl using a <a href="https://trixi-framework.github.io/TrixiBottomTopography.jl/stable/reference/#TrixiBottomTopography.BicubicBSpline"><code>BicubicBSpline</code></a> with the &quot;not-a-knot&quot; boundary closure. For this we first download the bathymetry data that has been preprocessed to be in the format required by TrixiBottomTopography, see <a href="https://trixi-framework.github.io/TrixiBottomTopography.jl/stable/conversion/#Data-format-of-TrixiBottomTopography.jl">here</a> for more information.</p><pre><code class="language-julia hljs">spline_bathymetry_file = Trixi.download(&quot;https://gist.githubusercontent.com/andrewwinters5000/21255c980c4eda5294f91e8dfe6c7e33/raw/1afb73928892774dc3a902e0c46ffd882ef03ee3/monai_bathymetry_data.txt&quot;,
                                        joinpath(@__DIR__, &quot;monai_bathymetry_data.txt&quot;));</code></pre><p>Create a bicubic B-spline interpolation of the bathymetry data, then create a function to evaluate the resulting spline at a given point <span>$(x,y)$</span>.</p><pre><code class="language-julia hljs">bath_spline_struct = BicubicBSpline(spline_bathymetry_file, end_condition = &quot;not-a-knot&quot;)
bathymetry(x, y) = spline_interpolation(bath_spline_struct, x, y);</code></pre><p>We then create a function to supply the initial condition for the simulation.</p><pre><code class="language-julia hljs">@inline function initial_condition_monai_tsunami(x, t,
                                                 equations::ShallowWaterEquationsWetDry2D)
    # Initially water is at rest
    v1 = 0.0
    v2 = 0.0

    # Bottom topography values are computed from the bicubic spline created above
    x1, x2 = x
    b = bathymetry(x1, x2)

    # It is mandatory to shift the water level at dry areas to make sure the water height h
    # stays positive. The system would not be stable for h set to a hard zero due to division by h in
    # the computation of velocity, e.g., (h v) / h. Therefore, a small dry state threshold
    # with a default value of 5*eps() ≈ 1e-13 in double precision, is set in the constructor above
    # for the ShallowWaterEquations and added to the initial condition if h = 0.
    # This default value can be changed within the constructor call depending on the simulation setup.
    h = max(equations.threshold_limiter, equations.H0 - b)

    # Return the conservative variables
    return SVector(h, h * v1, h * v2, b)
end

initial_condition = initial_condition_monai_tsunami;</code></pre><p>For this tsunami test case a specialized wave maker type of boundary condition is needed. It is used to model an incident wave that approaches from off-shore with a water depth of <span>$h = 13.535\,\text{cm}$</span>. To create the incident wave information that is valid over the time interval <span>$t \in [0\,s, 22.5\,s]$</span> we use a <a href="https://trixi-framework.github.io/HOHQMesh.jl/stable/reference/#HOHQMesh.CubicBspline"><code>CubicBspline</code></a> to interpolate the given data from the reference data.</p><p>We download the incident wave data that has been preprocessed to be in the format required by TrixiBottomTopography.</p><pre><code class="language-julia hljs">wavemaker_bc_file = Trixi.download(&quot;https://gist.githubusercontent.com/andrewwinters5000/5b11f5f175bddb326d11d8e28398127e/raw/64980e0e4526e0fcd49589b34ee5458b9a1cebff/monai_wavemaker_bc.txt&quot;,
                                   joinpath(@__DIR__, &quot;monai_wavemaker_bc.txt&quot;));</code></pre><p>Similar to the bathymetry approximation, we construct a cubic B-spline interpolation of the data, then create a function to evaluate the resulting spline at a given <span>$t$</span> value.</p><pre><code class="language-julia hljs">h_spline_struct = CubicBSpline(wavemaker_bc_file; end_condition = &quot;not-a-knot&quot;)
H_from_wave_maker(t) = spline_interpolation(h_spline_struct, t);</code></pre><p>Now we are equipped to define the specialized boundary condition for the incident wave maker.</p><pre><code class="language-julia hljs">@inline function boundary_condition_wave_maker(u_inner, normal_direction::AbstractVector,
                                               x, t, surface_flux_functions,
                                               equations::ShallowWaterEquationsWetDry2D)
    # Extract the numerical flux functions to compute the conservative and nonconservative
    # pieces of the approximation
    surface_flux_function, nonconservative_flux_function = surface_flux_functions

    # Compute the water height from the wave maker input file data
    # and then clip to avoid negative water heights and division by zero
    h_ext = max(equations.threshold_limiter, H_from_wave_maker(t) - u_inner[4])

    # Compute the incoming velocity as in Eq. (10) of the paper
    # - S. Vater, N. Beisiegel, and J. Behrens (2019)
    #   A limiter-based well-balanced discontinuous Galerkin method for shallow-water flows
    #   with wetting and drying: Triangular grids
    #   [DOI: 10.1002/fld.4762](https://doi.org/10.1002/fld.4762)
    h0 = 0.13535 # reference incident water height converted to meters
    v1_ext = 2 * (sqrt(equations.gravity * h_ext) - sqrt(equations.gravity * h0))

    # Create the external solution state in the conservative variables
    u_outer = SVector(h_ext, h_ext * v1_ext, zero(eltype(x)), u_inner[4])

    # Calculate the boundary flux and nonconservative contributions
    flux = surface_flux_function(u_inner, u_outer, normal_direction, equations)

    noncons_flux = nonconservative_flux_function(u_inner, u_outer, normal_direction,
                                                 equations)

    return flux, noncons_flux
end;</code></pre><p>We create the dictionary that assigns the different boundary conditions to physical boundary names. The names for the rectangular domain, e.g. <code>Bottom</code> are the default names provided by HOHQMesh. As per the problem definition, three of the domain boundaries are walls and the incident wave maker boundary condition implemented above is set at the <code>Left</code> domain</p><pre><code class="language-julia hljs">boundary_condition = Dict(:Bottom =&gt; boundary_condition_slip_wall,
                          :Top =&gt; boundary_condition_slip_wall,
                          :Right =&gt; boundary_condition_slip_wall,
                          :Left =&gt; boundary_condition_wave_maker);</code></pre><p>For this application, we also need to model the bottom friction. Thus, we create a new source term, which adds a Manning friction term to the momentum equations.</p><pre><code class="language-julia hljs">@inline function source_terms_manning_friction(u, x, t,
                                               equations::ShallowWaterEquationsWetDry2D)
    h, hv_1, hv_2, _ = u

    n = 0.001 # friction coefficient
    h = (h^2 + max(h^2, 1e-8)) / (2.0 * h) # desingularization procedure

    # Compute the common friction term
    Sf = -equations.gravity * n^2 * h^(-7 / 3) * sqrt(hv_1^2 + hv_2^2)

    return SVector(zero(eltype(x)), Sf * hv_1, Sf * hv_2, zero(eltype(x)))
end;</code></pre><p>Now we construct the approximation space, where we use the discontinuous Galerkin spectral element method (<a href="https://trixi-framework.github.io/Trixi.jl/stable/reference-trixi/#Trixi.DGSEM"><code>DGSEM</code></a>), with a volume integral in flux differencing formulation. For this we first need to specify fluxes for both volume and surface integrals. Since the system is setup in nonconservative form the fluxes need to provided in form of a tuple <code>flux = (conservative flux, nonconservative_flux)</code>. To ensure well-balancedness and positivity a reconstruction procedure is applied for the surface fluxes and a special shock-capturing scheme is used to compute the volume integrals. For the <code>surface_flux</code> we specify an HLL-type solver <code>flux_hll_chen_noelle</code> that uses the wave speed estimate <a href="../../reference/#TrixiShallowWater.min_max_speed_chen_noelle-Tuple{Any, Any, Integer, ShallowWaterEquationsWetDry1D}"><code>min_max_speed_chen_noelle</code></a> together with the hydrostatic reconstruction procedure <a href="../../reference/#TrixiShallowWater.hydrostatic_reconstruction_chen_noelle-Tuple{Any, Any, ShallowWaterEquationsWetDry1D}"><code>hydrostatic_reconstruction_chen_noelle</code></a> to ensure positivity and that the approximation is well-balanced.</p><pre><code class="language-julia hljs">volume_flux = (flux_wintermeyer_etal, flux_nonconservative_wintermeyer_etal)
surface_flux = (FluxHydrostaticReconstruction(flux_hll_chen_noelle,
                                              hydrostatic_reconstruction_chen_noelle),
                flux_nonconservative_chen_noelle)

basis = LobattoLegendreBasis(7) # polynomial approximation space with degree 7

indicator_sc = IndicatorHennemannGassnerShallowWater(equations, basis,
                                                     alpha_max = 0.5,
                                                     alpha_min = 0.001,
                                                     alpha_smooth = true,
                                                     variable = waterheight)
volume_integral = VolumeIntegralShockCapturingHG(indicator_sc;
                                                 volume_flux_dg = volume_flux,
                                                 volume_flux_fv = surface_flux)

solver = DGSEM(basis, surface_flux, volume_integral)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ DG{Float64}                                                                                      │
│ ═══════════                                                                                      │
│ basis: ……………………………………………………………… LobattoLegendreBasis{Float64}(polydeg=7)                         │
│ mortar: …………………………………………………………… LobattoLegendreMortarL2{Float64}(polydeg=7)                      │
│ surface integral: ………………………………… SurfaceIntegralWeakForm                                          │
│ │ surface flux: ……………………………………… (Trixi.FluxHydrostaticReconstruc…ux_nonconservative_chen_noelle) │
│ volume integral: …………………………………… VolumeIntegralShockCapturingHG                                   │
│ │ volume flux DG: ………………………………… (Trixi.flux_wintermeyer_etal, Tr…nconservative_wintermeyer_etal) │
│ │ volume flux FV: ………………………………… (Trixi.FluxHydrostaticReconstruc…ux_nonconservative_chen_noelle) │
│ │ indicator: ……………………………………………… IndicatorHennemannGassnerShallowWater                            │
│ │ │ indicator variable: ………………… waterheight                                                      │
│ │ │ max. α: ………………………………………………… 0.5                                                              │
│ │ │ min. α: ………………………………………………… 0.001                                                            │
│ │ │ smooth α: …………………………………………… yes                                                              │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>The mesh is created using the <code>UnstructuredMesh2D</code> type. The mesh is constructed by reading in the mesh file created by HOHQMesh and written to the directory <code>out</code>.</p><pre><code class="language-julia hljs">mesh_file = joinpath(@__DIR__, &quot;out&quot;, &quot;monai_shore.mesh&quot;)

mesh = UnstructuredMesh2D(mesh_file)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ UnstructuredMesh2D{2, Float64, Trixi.CurvedSurface{Float64}}                                     │
│ ════════════════════════════════════════════════════════════                                     │
│ mesh file: …………………………………………………… /home/runner/work/TrixiShallowWa…/tutorials/out/monai_shore.mesh │
│ number of elements: …………………………… 574                                                              │
│ faces: ……………………………………………………………… 1173                                                             │
│ mesh polynomial degree: ………………… 1                                                                │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>The semi-discretization object combines the mesh, equations, initial condition, solver, boundary conditions, and source terms into a single object. This object represents the spatial discretization of the problem.</p><pre><code class="language-julia hljs">semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver;
                                    boundary_conditions = boundary_condition,
                                    source_terms = source_terms_manning_friction);</code></pre><p>The semidiscretization is complemented with the time interval over which the problem will be integrated and needed to define an ODE problem for time integration.</p><pre><code class="language-julia hljs">tspan = (0.0, 22.5)
ode = semidiscretize(semi, tspan);</code></pre><p>Callbacks are used to monitor the simulation, save results, and control the time step size. Below, we define several callbacks for different purposes.</p><h3 id="Analysis-Callback"><a class="docs-heading-anchor" href="#Analysis-Callback">Analysis Callback</a><a id="Analysis-Callback-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-Callback" title="Permalink"></a></h3><p>The <a href="https://trixi-framework.github.io/Trixi.jl/stable/reference-trixi/#Trixi.AnalysisCallback">AnalysisCallback</a> is used to analyze the solution at regular intervals. Extra analysis quantities such as conservation errors can be added to the callback.</p><pre><code class="language-julia hljs">analysis_interval = 1000
analysis_callback = AnalysisCallback(semi, interval = analysis_interval)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ AnalysisCallback                                                                                 │
│ ════════════════                                                                                 │
│ interval: ……………………………………………………… 1000                                                             │
│ analyzer: ……………………………………………………… LobattoLegendreAnalyzer{Float64}(polydeg=14)                     │
│ │ error 1: …………………………………………………… l2_error                                                         │
│ │ error 2: …………………………………………………… linf_error                                                       │
│ │ integral 1: …………………………………………… entropy_timederivative                                           │
│ save analysis to file: …………………… no                                                               │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><h3 id="Save-Solution-Callback"><a class="docs-heading-anchor" href="#Save-Solution-Callback">Save Solution Callback</a><a id="Save-Solution-Callback-1"></a><a class="docs-heading-anchor-permalink" href="#Save-Solution-Callback" title="Permalink"></a></h3><p>The <a href="https://trixi-framework.github.io/Trixi.jl/stable/reference-trixi/#Trixi.SaveSolutionCallback"><code>SaveSolutionCallback</code></a> outputs solution data and other quantities like the shock capturing parameter to <code>.h5</code> files for postprocessing</p><pre><code class="language-julia hljs">save_solution = SaveSolutionCallback(dt = 0.5,
                                     save_initial_solution = true,
                                     save_final_solution = true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ SaveSolutionCallback                                                                             │
│ ════════════════════                                                                             │
│ dt: ……………………………………………………………………… 0.5                                                              │
│ solution variables: …………………………… cons2prim                                                        │
│ save initial solution: …………………… yes                                                              │
│ save final solution: ………………………… yes                                                              │
│ output directory: ………………………………… /home/runner/work/TrixiShallowWa…l/TrixiShallowWater.jl/docs/out │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><h3 id="Stepsize-Callback"><a class="docs-heading-anchor" href="#Stepsize-Callback">Stepsize Callback</a><a id="Stepsize-Callback-1"></a><a class="docs-heading-anchor-permalink" href="#Stepsize-Callback" title="Permalink"></a></h3><p>The <a href="https://trixi-framework.github.io/Trixi.jl/stable/reference-trixi/#Trixi.StepsizeCallback">StepsizeCallback</a> calculates the time step based on a CFL condition.</p><pre><code class="language-julia hljs">stepsize_callback = StepsizeCallback(cfl = 0.6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ StepsizeCallback                                                                                 │
│ ════════════════                                                                                 │
│ CFL number: ………………………………………………… 0.6                                                              │
│ Interval: ……………………………………………………… 1.0                                                              │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><h3 id="Combine-Callbacks"><a class="docs-heading-anchor" href="#Combine-Callbacks">Combine Callbacks</a><a id="Combine-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Combine-Callbacks" title="Permalink"></a></h3><p>All the defined callbacks are combined into a single <code>CallbackSet</code>.</p><pre><code class="language-julia hljs">callbacks = CallbackSet(analysis_callback,
                        stepsize_callback,
                        save_solution);</code></pre><h2 id="Run-the-simulation"><a class="docs-heading-anchor" href="#Run-the-simulation">Run the simulation</a><a id="Run-the-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Run-the-simulation" title="Permalink"></a></h2><p>Finally, we solve the ODE problem using a strong stability-preserving Runge-Kutta (SSPRK) method. The <a href="https://github.com/trixi-framework/TrixiShallowWater.jl/pull/index.html#TrixiShallowWater.PositivityPreservingLimiterShallowWater">PositivityPreservingLimiterShallowWater</a> is used as a stage limiter to ensure positivity of the water height during the simulation. The <a href="https://docs.sciml.ai/OrdinaryDiffEq/stable/explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK43">SSPRK43</a> integrator supports adaptive timestepping; however, this is deactivated with <code>adaptive=false</code> as we use a CFL-based time step restriction.</p><pre><code class="language-julia hljs">stage_limiter! = PositivityPreservingLimiterShallowWater(variables = (waterheight,))
sol = solve(ode, SSPRK43(stage_limiter!); dt = 1.0,
          ode_default_options()..., callback = callbacks, adaptive = false);</code></pre><h2 id="Postprocessing-the-solution-data"><a class="docs-heading-anchor" href="#Postprocessing-the-solution-data">Postprocessing the solution data</a><a id="Postprocessing-the-solution-data-1"></a><a class="docs-heading-anchor-permalink" href="#Postprocessing-the-solution-data" title="Permalink"></a></h2><p>It is useful to visualize and inspect the solution and bathymetry of the shallow water equations. One option available is post-processing the Trixi.jl output file(s) with the Trixi2Vtk.jl functionality and plotting them with ParaView.</p><p>To convert all the HDF5-formatted <code>.h5</code> output file(s) from TrixiShallowWater.jl into VTK format execute the following</p><pre><code class="language-julia hljs">trixi2vtk(&quot;out/solution_*.h5&quot;, output_directory = &quot;out&quot;)</code></pre><p>then it is possible to open the <code>.pvd</code> file with ParaView and create a video of the simulation. In addition, the <code>trixi2vtk</code> call will create <code>celldata</code> files if one wishes to plot the shock capturing parameter.</p><p>In ParaView, after opening the appropriate solution <code>.pvd</code> file, one can apply two instances of the <code>Warp By Scalar</code> filter to visualize the water height and bathymetry in three dimensions. Many additional customizations, e.g., color scaling, fonts, etc. are available in ParaView. An example of the output at the final time <span>$22.5$</span> is given below.</p><p><img src="https://github.com/user-attachments/assets/bc676f3a-4673-4fd7-9385-a9b0415598af" alt="paraview_example"/></p><h2 id="Putting-it-all-together"><a class="docs-heading-anchor" href="#Putting-it-all-together">Putting it all together</a><a id="Putting-it-all-together-1"></a><a class="docs-heading-anchor-permalink" href="#Putting-it-all-together" title="Permalink"></a></h2><p>Now the problem discretization components are assembled and working together with a postprocessing pipeline. We run the simulation, which takes approximately 12 minutes with solution files in the <code>SaveSolutionCallback</code> written every <code>dt = 0.04</code> to obtain a high temporal resolution of the solution output. We then visualize the solution, bathymetry, and shock capturing using ParaView and create a video of the <a href="https://www.youtube.com/watch?v=osyx48Qn10U">tsunami runup simulation</a>.</p>  <!--
  Video details
  * Source: https://www.youtube.com/watch?v=osyx48Qn10U
  * Author: Andrew R. Winters (https://liu.se/en/employee/andwi94)
  * Obtain responsive code by inserting link on https://embedresponsively.com
  -->
  <style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/osyx48Qn10U' frameborder='0' allowfullscreen></iframe></div><p>Source: Trixi.jl&#39;s YouTube channel <a href="https://www.youtube.com/channel/UCpd92vU2HjjTPup-AIN0pkg"><code>Trixi Framework</code></a></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../elixir_shallowwater_dam_break_triangular/">« Dam break over triangular bottom topograhy</a><a class="docs-footer-nextpage" href="../../development/">Development »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Tuesday 15 April 2025 12:47">Tuesday 15 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
